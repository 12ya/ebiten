// Code generated by file2byteslice. DO NOT EDIT.
// (gofmt is fine after generating)

package stb

var decode_js = []byte("// Copyright 2018 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _ebiten = {};\n\n(() => {\n  var decodeMemory = null;\n  var vorbisDecoderInitialized = null;\n\n  _ebiten.initializeVorbisDecoder = (callback) => {\n    Module.run();\n    vorbisDecoderInitialized = callback;\n  };\n\n  Module.onRuntimeInitialized = () => {\n    decodeMemory = Module.cwrap('stb_vorbis_decode_memory', 'number', ['number', 'number', 'number', 'number', 'number']);\n    if (vorbisDecoderInitialized) {\n      vorbisDecoderInitialized();\n    }\n  }\n\n  function arrayToHeap(typedArray){\n    const ptr = Module._malloc(typedArray.byteLength);\n    const heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, typedArray.byteLength);\n    heapBytes.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength));\n    return heapBytes;\n  }\n\n  function ptrToInt32(ptr) {\n    const a = new Int32Array(Module.HEAPU8.buffer, ptr, 1);\n    return a[0];\n  }\n\n  function ptrToFloat32(ptr) {\n    const a = new Float32Array(Module.HEAPU8.buffer, ptr, 1);\n    return a[0];\n  }\n\n  function ptrToInt16s(ptr, length) {\n    const buf = new ArrayBuffer(length * Int16Array.BYTES_PER_ELEMENT);\n    const copied = new Int16Array(buf);\n    copied.set(new Int16Array(Module.HEAPU8.buffer, ptr, length));\n    return copied;\n  }\n\n  _ebiten.decodeVorbis = (buf) => {\n    const copiedBuf = arrayToHeap(buf);\n    const channelsPtr = Module._malloc(4);\n    const sampleRatePtr = Module._malloc(4);\n    const outputPtr = Module._malloc(4);\n    const length = decodeMemory(copiedBuf.byteOffset, copiedBuf.length, channelsPtr, sampleRatePtr, outputPtr);\n    if (length < 0) {\n      return null;\n    }\n    const channels = ptrToInt32(channelsPtr);\n    const result = {\n      data:       ptrToInt16s(ptrToInt32(outputPtr), length * channels),\n      channels:   channels,\n      sampleRate: ptrToInt32(sampleRatePtr),\n    };\n\n    Module._free(copiedBuf.byteOffset);\n    Module._free(channelsPtr);\n    Module._free(sampleRatePtr);\n    Module._free(ptrToInt32(outputPtr));\n    Module._free(outputPtr);\n    return result;\n  };\n})();\n")
