// Code generated by file2byteslice. DO NOT EDIT.
// (gofmt is fine after generating)

package stb

var stbvorbis_js = []byte("// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nModule['arguments'] = [];\nModule['thisProgram'] = './this.program';\nModule['quit'] = function(status, toThrow) {\n  throw toThrow;\n};\nModule['preRun'] = [];\nModule['postRun'] = [];\n\n// The environment setup code below is customized to use Module.\n// *** Environment setup code ***\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\n\n// Three configurations we can be running in:\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\nif (Module['ENVIRONMENT']) {\n  if (Module['ENVIRONMENT'] === 'WEB') {\n    ENVIRONMENT_IS_WEB = true;\n  } else if (Module['ENVIRONMENT'] === 'WORKER') {\n    ENVIRONMENT_IS_WORKER = true;\n  } else if (Module['ENVIRONMENT'] === 'NODE') {\n    ENVIRONMENT_IS_NODE = true;\n  } else if (Module['ENVIRONMENT'] === 'SHELL') {\n    ENVIRONMENT_IS_SHELL = true;\n  } else {\n    throw new Error('Module[\\'ENVIRONMENT\\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');\n  }\n} else {\n  ENVIRONMENT_IS_WEB = typeof window === 'object';\n  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n  ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n}\n\n\nif (ENVIRONMENT_IS_NODE) {\n  // Expose functionality in the same simple way that the shells work\n  // Note that we pollute the global namespace here, otherwise we break in node\n  var nodeFS;\n  var nodePath;\n\n  Module['read'] = function shell_read(filename, binary) {\n    var ret;\n      if (!nodeFS) nodeFS = require('fs');\n      if (!nodePath) nodePath = require('path');\n      filename = nodePath['normalize'](filename);\n      ret = nodeFS['readFileSync'](filename);\n    return binary ? ret : ret.toString();\n  };\n\n  Module['readBinary'] = function readBinary(filename) {\n    var ret = Module['read'](filename, true);\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n    assert(ret.buffer);\n    return ret;\n  };\n\n  if (process['argv'].length > 1) {\n    Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  Module['arguments'] = process['argv'].slice(2);\n\n  if (typeof module !== 'undefined') {\n    module['exports'] = Module;\n  }\n\n  process['on']('uncaughtException', function(ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n  // Currently node will swallow unhandled rejections, but this behavior is\n  // deprecated, and in the future it will exit with error status.\n  process['on']('unhandledRejection', function(reason, p) {\n    process['exit'](1);\n  });\n\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\n} else\nif (ENVIRONMENT_IS_SHELL) {\n  if (typeof read != 'undefined') {\n    Module['read'] = function shell_read(f) {\n      return read(f);\n    };\n  }\n\n  Module['readBinary'] = function readBinary(f) {\n    var data;\n    if (typeof readbuffer === 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n    data = read(f, 'binary');\n    assert(typeof data === 'object');\n    return data;\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    Module['arguments'] = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    Module['arguments'] = arguments;\n  }\n\n  if (typeof quit === 'function') {\n    Module['quit'] = function(status, toThrow) {\n      quit(status);\n    }\n  }\n} else\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  Module['read'] = function shell_read(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    Module['readBinary'] = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n    };\n  }\n\n  Module['readAsync'] = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n  Module['setWindowTitle'] = function(title) { document.title = title };\n} else\n{\n  throw new Error('not compiled for this environment');\n}\n\n// console.log is checked first, as 'print' on the web will open a print dialogue\n// printErr is preferable to console.warn (works better in shells)\n// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\nModule['print'] = typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null);\nModule['printErr'] = typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || Module['print']);\n\n// *** Environment setup code ***\n\n// Closure helpers\nModule.print = Module['print'];\nModule.printErr = Module['printErr'];\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = undefined;\n\n\n\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16;\n\n\nfunction staticAlloc(size) {\n  assert(!staticSealed);\n  var ret = STATICTOP;\n  STATICTOP = (STATICTOP + size + 15) & -16;\n  return ret;\n}\n\nfunction dynamicAlloc(size) {\n  assert(DYNAMICTOP_PTR);\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\n  var end = (ret + size + 15) & -16;\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\n  if (end >= TOTAL_MEMORY) {\n    var success = enlargeMemory();\n    if (!success) {\n      HEAP32[DYNAMICTOP_PTR>>2] = ret;\n      return 0;\n    }\n  }\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  var ret = size = Math.ceil(size / factor) * factor;\n  return ret;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = parseInt(type.substr(1));\n        assert(bits % 8 === 0);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    Module.printErr(text);\n  }\n}\n\nvar asm2wasmImports = { // special asm2wasm imports\n    \"f64-rem\": function(x, y) {\n        return x % y;\n    },\n    \"debugger\": function() {\n        debugger;\n    }\n};\n\n\n\nvar jsCallStartIndex = 1;\nvar functionPointers = new Array(0);\n\n// 'sig' parameter is only used on LLVM wasm backend\nfunction addFunction(func, sig) {\n  var base = 0;\n  for (var i = base; i < base + 0; i++) {\n    if (!functionPointers[i]) {\n      functionPointers[i] = func;\n      return jsCallStartIndex + i;\n    }\n  }\n  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n}\n\nfunction removeFunction(index) {\n  functionPointers[index-jsCallStartIndex] = null;\n}\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n  assert(sig);\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n  var sigCache = funcWrappers[sig];\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n  return sigCache[func];\n}\n\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\n\n\nvar Runtime = {\n  // FIXME backwards compatibility layer for ports. Support some Runtime.*\n  //       for now, fix it there, then remove it from here. That way we\n  //       can minimize any period of breakage.\n  dynCall: dynCall, // for SDL2 port\n};\n\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\nvar GLOBAL_BASE = 1024;\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n\n\n//========================================\n// Runtime essentials\n//========================================\n\nvar ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\nvar globalScope = this;\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\nvar JSfuncs = {\n  // Helpers for cwrap -- it can't refer to Runtime directly because it might\n  // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n  // out what the minified function name is.\n  'stackSave': function() {\n    stackSave()\n  },\n  'stackRestore': function() {\n    stackRestore()\n  },\n  // type conversion from js to c\n  'arrayToC' : function(arr) {\n    var ret = stackAlloc(arr.length);\n    writeArrayToMemory(arr, ret);\n    return ret;\n  },\n  'stringToC' : function(str) {\n    var ret = 0;\n    if (str !== null && str !== undefined && str !== 0) { // null string\n      // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n      var len = (str.length << 2) + 1;\n      ret = stackAlloc(len);\n      stringToUTF8(str, ret, len);\n    }\n    return ret;\n  }\n};\n\n// For fast lookup of conversion functions\nvar toC = {\n  'string': JSfuncs['stringToC'], 'array': JSfuncs['arrayToC']\n};\n\n// C calling interface.\nfunction ccall (ident, returnType, argTypes, args, opts) {\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n  if (returnType === 'string') ret = Pointer_stringify(ret);\n  else if (returnType === 'boolean') ret = Boolean(ret);\n  if (stack !== 0) {\n    stackRestore(stack);\n  }\n  return ret;\n}\n\nfunction cwrap (ident, returnType, argTypes) {\n  argTypes = argTypes || [];\n  var cfunc = getCFunc(ident);\n  // When the function takes numbers and returns a number, we can just return\n  // the original function\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\n  var numericRet = returnType !== 'string';\n  if (numericRet && numericArgs) {\n    return cfunc;\n  }\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments);\n  }\n}\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  return null;\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_STATIC = 2; // Cannot be freed\nvar ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 4; // Do not allocate\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!staticSealed) return staticAlloc(size);\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n\n/** @type {function(number, number=)} */\nfunction Pointer_stringify(ptr, length) {\n  if (length === 0 || !ptr) return '';\n  // Find the length, and check for UTF while doing so\n  var hasUtf = 0;\n  var t;\n  var i = 0;\n  while (1) {\n    t = HEAPU8[(((ptr)+(i))>>0)];\n    hasUtf |= t;\n    if (t == 0 && !length) break;\n    i++;\n    if (length && i == length) break;\n  }\n  if (!length) length = i;\n\n  var ret = '';\n\n  if (hasUtf < 128) {\n    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n    var curr;\n    while (length > 0) {\n      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n      ret = ret ? ret + curr : curr;\n      ptr += MAX_CHUNK;\n      length -= MAX_CHUNK;\n    }\n    return ret;\n  }\n  return UTF8ToString(ptr);\n}\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAP8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\nfunction UTF8ArrayToString(u8Array, idx) {\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  while (u8Array[endPtr]) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var u0, u1, u2, u3, u4, u5;\n\n    var str = '';\n    while (1) {\n      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n      u0 = u8Array[idx++];\n      if (!u0) return str;\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      u1 = u8Array[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      u2 = u8Array[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u3 = u8Array[idx++] & 63;\n        if ((u0 & 0xF8) == 0xF0) {\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n        } else {\n          u4 = u8Array[idx++] & 63;\n          if ((u0 & 0xFC) == 0xF8) {\n            u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\n          } else {\n            u5 = u8Array[idx++] & 63;\n            u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\n          }\n        }\n      }\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction UTF8ToString(ptr) {\n  return UTF8ArrayToString(HEAPU8,ptr);\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x1FFFFF) {\n      if (outIdx + 3 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x3FFFFFF) {\n      if (outIdx + 4 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF8 | (u >> 24);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 5 >= endIdx) break;\n      outU8Array[outIdx++] = 0xFC | (u >> 30);\n      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      ++len;\n    } else if (u <= 0x7FF) {\n      len += 2;\n    } else if (u <= 0xFFFF) {\n      len += 3;\n    } else if (u <= 0x1FFFFF) {\n      len += 4;\n    } else if (u <= 0x3FFFFFF) {\n      len += 5;\n    } else {\n      len += 6;\n    }\n  }\n  return len;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\nfunction UTF16ToString(ptr) {\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  while (HEAP16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n\n    var str = '';\n    while (1) {\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n      if (codeUnit == 0) return str;\n      ++i;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)]=codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr) {\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)]=codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\nfunction demangle(func) {\n  return func;\n}\n\nfunction demangleAll(text) {\n  var regex =\n    /__Z[\\w\\d_]+/g;\n  return text.replace(regex,\n    function(x) {\n      var y = demangle(x);\n      return x === y ? x : (x + ' [' + y + ']');\n    });\n}\n\nfunction jsStackTrace() {\n  var err = new Error();\n  if (!err.stack) {\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n    // so try that as a special-case.\n    try {\n      throw new Error(0);\n    } catch(e) {\n      err = e;\n    }\n    if (!err.stack) {\n      return '(no stack trace available)';\n    }\n  }\n  return err.stack.toString();\n}\n\nfunction stackTrace() {\n  var js = jsStackTrace();\n  if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n  return demangleAll(js);\n}\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\nvar MIN_TOTAL_MEMORY = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBuffer(buf) {\n  Module['buffer'] = buffer = buf;\n}\n\nfunction updateGlobalBufferViews() {\n  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n}\n\nvar STATIC_BASE, STATICTOP, staticSealed; // static area\nvar STACK_BASE, STACKTOP, STACK_MAX; // stack area\nvar DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\n  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\n  staticSealed = false;\n\n\n\nfunction abortOnCannotGrowMemory() {\n  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n}\n\nif (!Module['reallocBuffer']) Module['reallocBuffer'] = function(size) {\n  var ret;\n  try {\n    if (ArrayBuffer.transfer) {\n      ret = ArrayBuffer.transfer(buffer, size);\n    } else {\n      var oldHEAP8 = HEAP8;\n      ret = new ArrayBuffer(size);\n      var temp = new Int8Array(ret);\n      temp.set(oldHEAP8);\n    }\n  } catch(e) {\n    return false;\n  }\n  var success = _emscripten_replace_memory(ret);\n  if (!success) return false;\n  return ret;\n};\n\nfunction enlargeMemory() {\n  // TOTAL_MEMORY is the current size of the actual array, and DYNAMICTOP is the new top.\n\n\n  var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n  var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.\n\n  if (HEAP32[DYNAMICTOP_PTR>>2] > LIMIT) {\n    return false;\n  }\n\n  var OLD_TOTAL_MEMORY = TOTAL_MEMORY;\n  TOTAL_MEMORY = Math.max(TOTAL_MEMORY, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.\n\n  while (TOTAL_MEMORY < HEAP32[DYNAMICTOP_PTR>>2]) { // Keep incrementing the heap size as long as it's less than what is requested.\n    if (TOTAL_MEMORY <= 536870912) {\n      TOTAL_MEMORY = alignUp(2 * TOTAL_MEMORY, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...\n    } else {\n      // ..., but after that, add smaller increments towards 2GB, which we cannot reach\n      TOTAL_MEMORY = Math.min(alignUp((3 * TOTAL_MEMORY + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);\n    }\n  }\n\n\n  var replacement = Module['reallocBuffer'](TOTAL_MEMORY);\n  if (!replacement || replacement.byteLength != TOTAL_MEMORY) {\n    // restore the state to before this call, we failed\n    TOTAL_MEMORY = OLD_TOTAL_MEMORY;\n    return false;\n  }\n\n  // everything worked\n\n  updateGlobalBuffer(replacement);\n  updateGlobalBufferViews();\n\n\n\n  return true;\n}\n\nvar byteLength;\ntry {\n  byteLength = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, 'byteLength').get);\n  byteLength(new ArrayBuffer(4)); // can fail on older ie\n} catch(e) { // can fail on older node/v8\n  byteLength = function(buffer) { return buffer.byteLength; };\n}\n\nvar TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;\nvar TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\nif (TOTAL_MEMORY < TOTAL_STACK) Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n// Initialize the runtime's memory\n\n\n\n// Use a provided buffer, if there is one, or else allocate a new one\nif (Module['buffer']) {\n  buffer = Module['buffer'];\n} else {\n  // Use a WebAssembly memory where available\n  if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {\n    Module['wasmMemory'] = new WebAssembly.Memory({ 'initial': TOTAL_MEMORY / WASM_PAGE_SIZE });\n    buffer = Module['wasmMemory'].buffer;\n  } else\n  {\n    buffer = new ArrayBuffer(TOTAL_MEMORY);\n  }\n  Module['buffer'] = buffer;\n}\nupdateGlobalBufferViews();\n\n\nfunction getTotalMemory() {\n  return TOTAL_MEMORY;\n}\n\n// Endianness check (note: assumes compiler arch was little-endian)\n  HEAP32[0] = 0x63736d65; /* 'emsc' */\nHEAP16[1] = 0x6373;\nif (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n  // compatibility - merge in anything from Module['preRun'] at this time\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction ensureInitRuntime() {\n  if (runtimeInitialized) return;\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  callRuntimeCallbacks(__ATEXIT__);\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  // compatibility - merge in anything from Module['postRun'] at this time\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n  __ATEXIT__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\nfunction getUniqueRunDependency(id) {\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\n\nvar memoryInitializer = null;\n\n\n\n\n\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ?\n      filename.startsWith(dataURIPrefix) :\n      filename.indexOf(dataURIPrefix) === 0;\n}\n\n\n\n\nfunction integrateWasmJS() {\n  // wasm.js has several methods for creating the compiled code module here:\n  //  * 'native-wasm' : use native WebAssembly support in the browser\n  //  * 'interpret-s-expr': load s-expression code from a .wast and interpret\n  //  * 'interpret-binary': load binary wasm and interpret\n  //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret\n  //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)\n  // The method is set at compile time (BINARYEN_METHOD)\n  // The method can be a comma-separated list, in which case, we will try the\n  // options one by one. Some of them can fail gracefully, and then we can try\n  // the next.\n\n  // inputs\n\n  var method = 'native-wasm';\n\n  var wasmTextFile = 'stbvorbis.wast';\n  var wasmBinaryFile = 'stbvorbis.wasm';\n  var asmjsCodeFile = 'stbvorbis.temp.asm.js';\n\n  if (typeof Module['locateFile'] === 'function') {\n    if (!isDataURI(wasmTextFile)) {\n      wasmTextFile = Module['locateFile'](wasmTextFile);\n    }\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = Module['locateFile'](wasmBinaryFile);\n    }\n    if (!isDataURI(asmjsCodeFile)) {\n      asmjsCodeFile = Module['locateFile'](asmjsCodeFile);\n    }\n  }\n\n  // utilities\n\n  var wasmPageSize = 64*1024;\n\n  var info = {\n    'global': null,\n    'env': null,\n    'asm2wasm': asm2wasmImports,\n    'parent': Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\n  };\n\n  var exports = null;\n\n\n  function mergeMemory(newBuffer) {\n    // The wasm instance creates its memory. But static init code might have written to\n    // buffer already, including the mem init file, and we must copy it over in a proper merge.\n    // TODO: avoid this copy, by avoiding such static init writes\n    // TODO: in shorter term, just copy up to the last static init write\n    var oldBuffer = Module['buffer'];\n    if (newBuffer.byteLength < oldBuffer.byteLength) {\n      Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');\n    }\n    var oldView = new Int8Array(oldBuffer);\n    var newView = new Int8Array(newBuffer);\n\n\n    newView.set(oldView);\n    updateGlobalBuffer(newBuffer);\n    updateGlobalBufferViews();\n  }\n\n  function fixImports(imports) {\n    return imports;\n  }\n\n  function getBinary() {\n    try {\n      if (Module['wasmBinary']) {\n        return new Uint8Array(Module['wasmBinary']);\n      }\n      if (Module['readBinary']) {\n        return Module['readBinary'](wasmBinaryFile);\n      } else {\n        throw \"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)\";\n      }\n    }\n    catch (err) {\n      abort(err);\n    }\n  }\n\n  function getBinaryPromise() {\n    // if we don't have the binary yet, and have the Fetch api, use that\n    // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n    if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n        if (!response['ok']) {\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n        }\n        return response['arrayBuffer']();\n      }).catch(function () {\n        return getBinary();\n      });\n    }\n    // Otherwise, getBinary should be able to get it synchronously\n    return new Promise(function(resolve, reject) {\n      resolve(getBinary());\n    });\n  }\n\n  // do-method functions\n\n\n  function doNativeWasm(global, env, providedBuffer) {\n    if (typeof WebAssembly !== 'object') {\n      Module['printErr']('no native wasm support detected');\n      return false;\n    }\n    // prepare memory import\n    if (!(Module['wasmMemory'] instanceof WebAssembly.Memory)) {\n      Module['printErr']('no native wasm Memory in use');\n      return false;\n    }\n    env['memory'] = Module['wasmMemory'];\n    // Load the wasm module and create an instance of using native support in the JS engine.\n    info['global'] = {\n      'NaN': NaN,\n      'Infinity': Infinity\n    };\n    info['global.Math'] = Math;\n    info['env'] = env;\n    // handle a generated wasm instance, receiving its exports and\n    // performing other necessary setup\n    function receiveInstance(instance, module) {\n      exports = instance.exports;\n      if (exports.memory) mergeMemory(exports.memory);\n      Module['asm'] = exports;\n      Module[\"usingWasm\"] = true;\n      removeRunDependency('wasm-instantiate');\n    }\n    addRunDependency('wasm-instantiate');\n\n    // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n    // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n    // to any other async startup actions they are performing.\n    if (Module['instantiateWasm']) {\n      try {\n        return Module['instantiateWasm'](info, receiveInstance);\n      } catch(e) {\n        Module['printErr']('Module.instantiateWasm callback failed with error: ' + e);\n        return false;\n      }\n    }\n\n    function receiveInstantiatedSource(output) {\n      // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n      // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n      receiveInstance(output['instance'], output['module']);\n    }\n    function instantiateArrayBuffer(receiver) {\n      getBinaryPromise().then(function(binary) {\n        return WebAssembly.instantiate(binary, info);\n      }).then(receiver).catch(function(reason) {\n        Module['printErr']('failed to asynchronously prepare wasm: ' + reason);\n        abort(reason);\n      });\n    }\n    // Prefer streaming instantiation if available.\n    if (!Module['wasmBinary'] &&\n        typeof WebAssembly.instantiateStreaming === 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch === 'function') {\n      WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials: 'same-origin' }), info)\n        .then(receiveInstantiatedSource)\n        .catch(function(reason) {\n          // We expect the most common failure cause to be a bad MIME type for the binary,\n          // in which case falling back to ArrayBuffer instantiation should work.\n          Module['printErr']('wasm streaming compile failed: ' + reason);\n          Module['printErr']('falling back to ArrayBuffer instantiation');\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n    } else {\n      instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n    return {}; // no exports yet; we'll fill them in later\n  }\n\n\n  // We may have a preloaded value in Module.asm, save it\n  Module['asmPreload'] = Module['asm'];\n\n  // Memory growth integration code\n\n  var asmjsReallocBuffer = Module['reallocBuffer'];\n\n  var wasmReallocBuffer = function(size) {\n    var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n    size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n    var old = Module['buffer'];\n    var oldSize = old.byteLength;\n    if (Module[\"usingWasm\"]) {\n      // native wasm support\n      try {\n        var result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\n        if (result !== (-1 | 0)) {\n          // success in native wasm memory growth, get the buffer from the memory\n          return Module['buffer'] = Module['wasmMemory'].buffer;\n        } else {\n          return null;\n        }\n      } catch(e) {\n        return null;\n      }\n    }\n  };\n\n  Module['reallocBuffer'] = function(size) {\n    if (finalMethod === 'asmjs') {\n      return asmjsReallocBuffer(size);\n    } else {\n      return wasmReallocBuffer(size);\n    }\n  };\n\n  // we may try more than one; this is the final one, that worked and we are using\n  var finalMethod = '';\n\n  // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\n  // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n  // doesn't need to care that it is wasm or olyfilled wasm or asm.js.\n\n  Module['asm'] = function(global, env, providedBuffer) {\n    env = fixImports(env);\n\n    // import table\n    if (!env['table']) {\n      var TABLE_SIZE = Module['wasmTableSize'];\n      if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least\n      var MAX_TABLE_SIZE = Module['wasmMaxTableSize'];\n      if (typeof WebAssembly === 'object' && typeof WebAssembly.Table === 'function') {\n        if (MAX_TABLE_SIZE !== undefined) {\n          env['table'] = new WebAssembly.Table({ 'initial': TABLE_SIZE, 'maximum': MAX_TABLE_SIZE, 'element': 'anyfunc' });\n        } else {\n          env['table'] = new WebAssembly.Table({ 'initial': TABLE_SIZE, element: 'anyfunc' });\n        }\n      } else {\n        env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\n      }\n      Module['wasmTable'] = env['table'];\n    }\n\n    if (!env['memoryBase']) {\n      env['memoryBase'] = Module['STATIC_BASE']; // tell the memory segments where to place themselves\n    }\n    if (!env['tableBase']) {\n      env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change\n    }\n\n    // try the methods. each should return the exports if it succeeded\n\n    var exports;\n    exports = doNativeWasm(global, env, providedBuffer);\n\n    assert(exports, 'no binaryen method succeeded.');\n\n\n    return exports;\n  };\n\n  var methodHandler = Module['asm']; // note our method handler, as we may modify Module['asm'] later\n}\n\nintegrateWasmJS();\n\n// === Body ===\n\nvar ASM_CONSTS = [];\n\n\n\n\n\nSTATIC_BASE = GLOBAL_BASE;\n\nSTATICTOP = STATIC_BASE + 3776;\n/* global initializers */  __ATINIT__.push();\n\n\n\n\n\n\n\nvar STATIC_BUMP = 3776;\nModule[\"STATIC_BASE\"] = STATIC_BASE;\nModule[\"STATIC_BUMP\"] = STATIC_BUMP;\n\n/* no memory initializer */\nvar tempDoublePtr = STATICTOP; STATICTOP += 16;\n\nfunction copyTempFloat(ptr) { // functions, because inlining this code increases code size too much\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n}\n\nfunction copyTempDouble(ptr) {\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];\n\n  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];\n\n  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];\n\n  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];\n\n}\n\n// {{PRE_LIBRARY}}\n\n\n  function ___assert_fail(condition, filename, line, func) {\n      abort('Assertion failed: ' + Pointer_stringify(condition) + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function']);\n    }\n\n  function _abort() {\n      Module['abort']();\n    }\n\n  var _llvm_floor_f64=Math_floor;\n\n  \n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n      return dest;\n    } \n\n   \n\n  \n  function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;\n      return value;\n    } \nDYNAMICTOP_PTR = staticAlloc(4);\n\nSTACK_BASE = STACKTOP = alignMemory(STATICTOP);\n\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\n\nDYNAMIC_BASE = alignMemory(STACK_MAX);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\nstaticSealed = true; // seal the static portion of memory\n\nvar ASSERTIONS = false;\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n\nModule['wasmTableSize'] = 4;\n\nModule['wasmMaxTableSize'] = 4;\n\nfunction invoke_iii(index,a1,a2) {\n  try {\n    return Module[\"dynCall_iii\"](index,a1,a2);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nModule.asmGlobalArg = {};\n\nModule.asmLibraryArg = { \"abort\": abort, \"assert\": assert, \"enlargeMemory\": enlargeMemory, \"getTotalMemory\": getTotalMemory, \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory, \"invoke_iii\": invoke_iii, \"___assert_fail\": ___assert_fail, \"___setErrNo\": ___setErrNo, \"_abort\": _abort, \"_emscripten_memcpy_big\": _emscripten_memcpy_big, \"_llvm_floor_f64\": _llvm_floor_f64, \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR, \"tempDoublePtr\": tempDoublePtr, \"ABORT\": ABORT, \"STACKTOP\": STACKTOP, \"STACK_MAX\": STACK_MAX };\n// EMSCRIPTEN_START_ASM\nvar asm =Module[\"asm\"]// EMSCRIPTEN_END_ASM\n(Module.asmGlobalArg, Module.asmLibraryArg, buffer);\n\nModule[\"asm\"] = asm;\nvar ___errno_location = Module[\"___errno_location\"] = function() {  return Module[\"asm\"][\"___errno_location\"].apply(null, arguments) };\nvar _emscripten_replace_memory = Module[\"_emscripten_replace_memory\"] = function() {  return Module[\"asm\"][\"_emscripten_replace_memory\"].apply(null, arguments) };\nvar _free = Module[\"_free\"] = function() {  return Module[\"asm\"][\"_free\"].apply(null, arguments) };\nvar _malloc = Module[\"_malloc\"] = function() {  return Module[\"asm\"][\"_malloc\"].apply(null, arguments) };\nvar _memcpy = Module[\"_memcpy\"] = function() {  return Module[\"asm\"][\"_memcpy\"].apply(null, arguments) };\nvar _memset = Module[\"_memset\"] = function() {  return Module[\"asm\"][\"_memset\"].apply(null, arguments) };\nvar _sbrk = Module[\"_sbrk\"] = function() {  return Module[\"asm\"][\"_sbrk\"].apply(null, arguments) };\nvar _stb_vorbis_decode_memory_float = Module[\"_stb_vorbis_decode_memory_float\"] = function() {  return Module[\"asm\"][\"_stb_vorbis_decode_memory_float\"].apply(null, arguments) };\nvar establishStackSpace = Module[\"establishStackSpace\"] = function() {  return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments) };\nvar getTempRet0 = Module[\"getTempRet0\"] = function() {  return Module[\"asm\"][\"getTempRet0\"].apply(null, arguments) };\nvar runPostSets = Module[\"runPostSets\"] = function() {  return Module[\"asm\"][\"runPostSets\"].apply(null, arguments) };\nvar setTempRet0 = Module[\"setTempRet0\"] = function() {  return Module[\"asm\"][\"setTempRet0\"].apply(null, arguments) };\nvar setThrew = Module[\"setThrew\"] = function() {  return Module[\"asm\"][\"setThrew\"].apply(null, arguments) };\nvar stackAlloc = Module[\"stackAlloc\"] = function() {  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments) };\nvar stackRestore = Module[\"stackRestore\"] = function() {  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments) };\nvar stackSave = Module[\"stackSave\"] = function() {  return Module[\"asm\"][\"stackSave\"].apply(null, arguments) };\nvar dynCall_iii = Module[\"dynCall_iii\"] = function() {  return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments) };\n;\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\n\n\n\nModule[\"ccall\"] = ccall;\nModule[\"cwrap\"] = cwrap;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @constructor\n * @extends {Error}\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n};\nExitStatus.prototype = new Error();\nExitStatus.prototype.constructor = ExitStatus;\n\nvar initialStackTop;\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!Module['calledRun']) run();\n  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n}\n\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || Module['arguments'];\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n\n  preRun();\n\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n  function doRun() {\n    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    ensureInitRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n}\nModule['run'] = run;\n\n\nfunction exit(status, implicit) {\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && Module['noExitRuntime'] && status === 0) {\n    return;\n  }\n\n  if (Module['noExitRuntime']) {\n  } else {\n\n    ABORT = true;\n    EXITSTATUS = status;\n    STACKTOP = initialStackTop;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  if (ENVIRONMENT_IS_NODE) {\n    process['exit'](status);\n  }\n  Module['quit'](status, new ExitStatus(status));\n}\nModule['exit'] = exit;\n\nvar abortDecorators = [];\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  if (what !== undefined) {\n    Module.print(what);\n    Module.printErr(what);\n    what = JSON.stringify(what)\n  } else {\n    what = '';\n  }\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';\n}\nModule['abort'] = abort;\n\n// {{PRE_RUN_ADDITIONS}}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\n\nModule[\"noExitRuntime\"] = true;\n\nrun();\n\n// {{POST_RUN_ADDITIONS}}\n\n\n\n\n\n// {{MODULE_ADDITIONS}}\n\n\n\n")
