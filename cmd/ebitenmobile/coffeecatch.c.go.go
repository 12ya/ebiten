// Code generated by file2byteslice. DO NOT EDIT.
// (gofmt is fine after generating)

package main

var coffeecatch_c_go = []byte("// Code generated by file2byteslice. DO NOT EDIT.\n// (gofmt is fine after generating)\n\n// +build ebitenmobilegobind\n\npackage main\n\nvar coffeecatch_c = []byte(\"/* CoffeeCatch, a tiny native signal handler/catcher for JNI code.\\n * (especially for Android/Dalvik)\\n *\\n * Copyright (c) 2013, Xavier Roche (http://www.httrack.com/)\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * 1. Redistributions of source code must retain the above copyright notice, this\\n *    list of conditions and the following disclaimer.\\n * 2. Redistributions in binary form must reproduce the above copyright notice,\\n *    this list of conditions and the following disclaimer in the documentation\\n *    and/or other materials provided with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND\\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n#ifdef __ANDROID__\\n#define USE_UNWIND\\n#define USE_CORKSCREW\\n#define USE_LIBUNWIND\\n#endif\\n\\n/* #undef NO_USE_SIGALTSTACK */\\n/* #undef USE_SILENT_SIGALTSTACK */\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdint.h>\\n#include <unistd.h>\\n#include <string.h>\\n#include <errno.h>\\n#include <sys/types.h>\\n#include <assert.h>\\n#include <signal.h>\\n#include <setjmp.h>\\n#if defined(__ANDROID__) && !defined(__BIONIC_HAVE_UCONTEXT_T) && \\\\\\n    defined(__arm__) && !defined(__BIONIC_HAVE_STRUCT_SIGCONTEXT)\\n#include <asm/sigcontext.h>\\n#endif \\n#if (defined(USE_UNWIND) && !defined(USE_CORKSCREW))\\n#include <unwind.h>\\n#endif\\n#include <pthread.h>\\n#include <dlfcn.h>\\n#include \\\"coffeecatch.h\\\"\\n\\n/*#define NDK_DEBUG 1*/\\n#if ( defined(NDK_DEBUG) && ( NDK_DEBUG == 1 ) )\\n#define DEBUG(A) do { A; } while(0)\\n#define FD_ERRNO 2\\nstatic void print(const char *const s) {\\n  size_t count;\\n  for(count = 0; s[count] != '\\\\0'; count++) ;\\n  /* write() is async-signal-safe. */\\n  (void) write(FD_ERRNO, s, count);\\n}\\n#else\\n#define DEBUG(A)\\n#endif\\n\\n/* Alternative stack size. */\\n#define SIG_STACK_BUFFER_SIZE SIGSTKSZ\\n\\n#ifdef USE_UNWIND\\n/* Number of backtraces to get. */\\n#define BACKTRACE_FRAMES_MAX 32\\n#endif\\n\\n/* Signals to be caught. */\\n#define SIG_CATCH_COUNT 7\\nstatic const int native_sig_catch[SIG_CATCH_COUNT + 1]\\n  = { SIGABRT, SIGILL, SIGTRAP, SIGBUS, SIGFPE, SIGSEGV\\n#ifdef SIGSTKFLT\\n    , SIGSTKFLT\\n#endif\\n    , 0 };\\n\\n/* Maximum value of a caught signal. */\\n#define SIG_NUMBER_MAX 32\\n\\n#if defined(__ANDROID__)\\n#ifndef ucontext_h_seen\\n#define ucontext_h_seen\\n\\n/* stack_t definition */\\n#include <asm/signal.h>\\n\\n#if defined(__arm__)\\n\\n/* Taken from richard.quirk's header file. (Android does not have it) */\\n\\n#if !defined(__BIONIC_HAVE_UCONTEXT_T)\\ntypedef struct ucontext {\\n  unsigned long uc_flags;\\n  struct ucontext *uc_link;\\n  stack_t uc_stack;\\n  struct sigcontext uc_mcontext;\\n  unsigned long uc_sigmask;\\n} ucontext_t;\\n#endif\\n\\n#elif defined(__aarch64__)\\n\\n#elif defined(__i386__)\\n\\n/* Taken from Google Breakpad. */\\n\\n/* 80-bit floating-point register */\\n/*struct _libc_fpreg {\\n  unsigned short significand[4];\\n  unsigned short exponent;\\n};*/\\n\\n/* Simple floating-point state, see FNSTENV instruction */\\n/*struct _libc_fpstate {\\n  unsigned long cw;\\n  unsigned long sw;\\n  unsigned long tag;\\n  unsigned long ipoff;\\n  unsigned long cssel;\\n  unsigned long dataoff;\\n  unsigned long datasel;\\n  struct _libc_fpreg _st[8];\\n  unsigned long status;\\n};*/\\n\\n//typedef uint32_t  greg_t;\\n\\n/*typedef struct {\\n  uint32_t gregs[19];\\n  struct _libc_fpstate* fpregs;\\n  uint32_t oldmask;\\n  uint32_t cr2;\\n} mcontext_t;*/\\n\\n/*enum {\\n  REG_GS = 0,\\n  REG_FS,\\n  REG_ES,\\n  REG_DS,\\n  REG_EDI,\\n  REG_ESI,\\n  REG_EBP,\\n  REG_ESP,\\n  REG_EBX,\\n  REG_EDX,\\n  REG_ECX,\\n  REG_EAX,\\n  REG_TRAPNO,\\n  REG_ERR,\\n  REG_EIP,\\n  REG_CS,\\n  REG_EFL,\\n  REG_UESP,\\n  REG_SS,\\n};*/\\n\\n#if !defined(__BIONIC_HAVE_UCONTEXT_T)\\ntypedef struct ucontext {\\n  uint32_t uc_flags;\\n  struct ucontext* uc_link;\\n  stack_t uc_stack;\\n  mcontext_t uc_mcontext;\\n} ucontext_t;\\n#endif\\n\\n#elif defined(__mips__)\\n\\n/* Taken from Google Breakpad. */\\n\\ntypedef struct {\\n  uint32_t regmask;\\n  uint32_t status;\\n  uint64_t pc;\\n  uint64_t gregs[32];\\n  uint64_t fpregs[32];\\n  uint32_t acx;\\n  uint32_t fpc_csr;\\n  uint32_t fpc_eir;\\n  uint32_t used_math;\\n  uint32_t dsp;\\n  uint64_t mdhi;\\n  uint64_t mdlo;\\n  uint32_t hi1;\\n  uint32_t lo1;\\n  uint32_t hi2;\\n  uint32_t lo2;\\n  uint32_t hi3;\\n  uint32_t lo3;\\n} mcontext_t;\\n\\n#if !defined(__BIONIC_HAVE_UCONTEXT_T)\\ntypedef struct ucontext {\\n  uint32_t uc_flags;\\n  struct ucontext* uc_link;\\n  stack_t uc_stack;\\n  mcontext_t uc_mcontext;\\n} ucontext_t;\\n#endif\\n\\n#else\\n#error \\\"Architecture is not supported (unknown ucontext layout)\\\"\\n#endif\\n\\n#endif\\n\\n#ifdef USE_CORKSCREW\\ntypedef struct map_info_t map_info_t;\\n/* Extracted from Android's include/corkscrew/backtrace.h */\\ntypedef struct {\\n    uintptr_t absolute_pc;\\n    uintptr_t stack_top;\\n    size_t stack_size;\\n} backtrace_frame_t;\\ntypedef struct {\\n    uintptr_t relative_pc;\\n    uintptr_t relative_symbol_addr;\\n    char* map_name;\\n    char* symbol_name;\\n    char* demangled_name;\\n} backtrace_symbol_t;\\n/* Extracted from Android's libcorkscrew/arch-arm/backtrace-arm.c */\\ntypedef ssize_t (*t_unwind_backtrace_signal_arch)\\n(siginfo_t* si, void* sc, const map_info_t* lst, backtrace_frame_t* bt,\\nsize_t ignore_depth, size_t max_depth);\\ntypedef map_info_t* (*t_acquire_my_map_info_list)();\\ntypedef void (*t_release_my_map_info_list)(map_info_t* milist);\\ntypedef void (*t_get_backtrace_symbols)(const backtrace_frame_t* backtrace,\\n                                        size_t frames,\\n                                        backtrace_symbol_t* symbols);\\ntypedef void (*t_free_backtrace_symbols)(backtrace_symbol_t* symbols,\\n                                         size_t frames);\\n#endif\\n\\n#endif\\n\\n/* Process-wide crash handler structure. */\\ntypedef struct native_code_global_struct {\\n  /* Initialized. */\\n  int initialized;\\n\\n  /* Lock. */\\n  pthread_mutex_t mutex;\\n\\n  /* Backup of sigaction. */\\n  struct sigaction *sa_old;\\n} native_code_global_struct;\\n#define NATIVE_CODE_GLOBAL_INITIALIZER { 0, PTHREAD_MUTEX_INITIALIZER, NULL }\\n\\n/* Thread-specific crash handler structure. */\\ntypedef struct native_code_handler_struct {\\n  /* Restore point context. */\\n  sigjmp_buf ctx;\\n  int ctx_is_set;\\n  int reenter;\\n\\n  /* Alternate stack. */\\n  char *stack_buffer;\\n  size_t stack_buffer_size;\\n  stack_t stack_old;\\n\\n  /* Signal code and info. */\\n  int code;\\n  siginfo_t si;\\n  ucontext_t uc;\\n\\n  /* Uwind context. */\\n#if (defined(USE_CORKSCREW))\\n  backtrace_frame_t frames[BACKTRACE_FRAMES_MAX];\\n#elif (defined(USE_UNWIND))\\n  uintptr_t frames[BACKTRACE_FRAMES_MAX];\\n#endif\\n#ifdef USE_LIBUNWIND\\n  void* uframes[BACKTRACE_FRAMES_MAX];\\n#endif\\n  size_t frames_size;\\n  size_t frames_skip;\\n\\n  /* Custom assertion failures. */\\n  const char *expression;\\n  const char *file;\\n  int line;\\n\\n  /* Alarm was fired. */\\n  int alarm;\\n} native_code_handler_struct;\\n\\n/* Global crash handler structure. */\\nstatic native_code_global_struct native_code_g =\\n  NATIVE_CODE_GLOBAL_INITIALIZER;\\n\\n/* Thread variable holding context. */\\npthread_key_t native_code_thread;\\n\\n#if (defined(USE_UNWIND) && !defined(USE_CORKSCREW))\\n/* Unwind callback */\\nstatic _Unwind_Reason_Code\\ncoffeecatch_unwind_callback(struct _Unwind_Context* context, void* arg) {\\n  native_code_handler_struct *const s = (native_code_handler_struct*) arg;\\n\\n  const uintptr_t ip = _Unwind_GetIP(context);\\n\\n  DEBUG(print(\\\"called unwind callback\\\\n\\\"));\\n\\n  if (ip != 0x0) {\\n    if (s->frames_skip == 0) {\\n      s->frames[s->frames_size] = ip;\\n      s->frames_size++;\\n    } else {\\n      s->frames_skip--;\\n    }\\n  }\\n\\n  if (s->frames_size == BACKTRACE_FRAMES_MAX) {\\n    return _URC_END_OF_STACK;\\n  } else {\\n    DEBUG(print(\\\"returned _URC_OK\\\\n\\\"));\\n    return _URC_OK;\\n  }\\n}\\n#endif\\n\\n/* Use libcorkscrew to get a backtrace inside a signal handler.\\n   Will only return a non-zero code on Android >= 4 (with libcorkscrew.so\\n   being shipped) */\\n#ifdef USE_CORKSCREW\\nstatic size_t coffeecatch_backtrace_signal(siginfo_t* si, void* sc, \\n                                           backtrace_frame_t* frames,\\n                                           size_t ignore_depth,\\n                                           size_t max_depth) {\\n  void *const libcorkscrew = dlopen(\\\"libcorkscrew.so\\\", RTLD_LAZY | RTLD_LOCAL);\\n  if (libcorkscrew != NULL) {\\n    t_unwind_backtrace_signal_arch unwind_backtrace_signal_arch \\n      = (t_unwind_backtrace_signal_arch)\\n      dlsym(libcorkscrew, \\\"unwind_backtrace_signal_arch\\\");\\n    t_acquire_my_map_info_list acquire_my_map_info_list \\n      = (t_acquire_my_map_info_list)\\n      dlsym(libcorkscrew, \\\"acquire_my_map_info_list\\\");\\n    t_release_my_map_info_list release_my_map_info_list \\n      = (t_release_my_map_info_list)\\n      dlsym(libcorkscrew, \\\"release_my_map_info_list\\\");\\n    if (unwind_backtrace_signal_arch != NULL\\n        && acquire_my_map_info_list != NULL\\n        && release_my_map_info_list != NULL) {\\n      map_info_t*const info = acquire_my_map_info_list();\\n      const ssize_t size = \\n        unwind_backtrace_signal_arch(si, sc, info, frames, ignore_depth,\\n                                     max_depth);\\n      release_my_map_info_list(info);\\n      return size >= 0 ? size : 0;\\n    } else {\\n      DEBUG(print(\\\"symbols not found in libcorkscrew.so\\\\n\\\"));\\n    }\\n    dlclose(libcorkscrew);\\n  } else {\\n    DEBUG(print(\\\"libcorkscrew.so could not be loaded\\\\n\\\"));\\n  }\\n  return 0;\\n}\\n\\nstatic int coffeecatch_backtrace_symbols(const backtrace_frame_t* backtrace,\\n                                         size_t frames,\\n                                         void (*fun)(void *arg,\\n                                         const backtrace_symbol_t *sym),\\n                                         void *arg) {\\n  int success = 0;\\n  void *const libcorkscrew = dlopen(\\\"libcorkscrew.so\\\", RTLD_LAZY | RTLD_LOCAL);\\n  if (libcorkscrew != NULL) {\\n    t_get_backtrace_symbols get_backtrace_symbols \\n      = (t_get_backtrace_symbols)\\n      dlsym(libcorkscrew, \\\"get_backtrace_symbols\\\");\\n    t_free_backtrace_symbols free_backtrace_symbols \\n      = (t_free_backtrace_symbols)\\n      dlsym(libcorkscrew, \\\"free_backtrace_symbols\\\");\\n    if (get_backtrace_symbols != NULL\\n        && free_backtrace_symbols != NULL) {\\n      backtrace_symbol_t symbols[BACKTRACE_FRAMES_MAX];\\n      size_t i;\\n      if (frames > BACKTRACE_FRAMES_MAX) {\\n        frames = BACKTRACE_FRAMES_MAX;\\n      }\\n      get_backtrace_symbols(backtrace, frames, symbols);\\n      for(i = 0; i < frames; i++) {\\n        fun(arg, &symbols[i]);\\n      }\\n      free_backtrace_symbols(symbols, frames);\\n      success = 1;\\n    } else {\\n      DEBUG(print(\\\"symbols not found in libcorkscrew.so\\\\n\\\"));\\n    }\\n    dlclose(libcorkscrew);\\n  } else {\\n    DEBUG(print(\\\"libcorkscrew.so could not be loaded\\\\n\\\"));\\n  }\\n  return success;\\n}\\n#endif\\n\\n/* Use libunwind to get a backtrace inside a signal handler.\\n   Will only return a non-zero code on Android >= 5 (with libunwind.so\\n   being shipped) */\\n#ifdef USE_LIBUNWIND\\nstatic ssize_t coffeecatch_unwind_signal(siginfo_t* si, void* sc, \\n                                         void** frames,\\n                                         size_t ignore_depth,\\n                                         size_t max_depth) {\\n  void *libunwind = dlopen(\\\"libunwind.so\\\", RTLD_LAZY | RTLD_LOCAL);\\n  if (libunwind != NULL) {\\n    int (*backtrace)(void **buffer, int size) =\\n      dlsym(libunwind, \\\"unw_backtrace\\\");\\n    if (backtrace != NULL) {\\n      int nb = backtrace(frames, max_depth);\\n      if (nb > 0) {\\n      }\\n      return nb;\\n    } else {\\n      DEBUG(print(\\\"symbols not found in libunwind.so\\\\n\\\"));\\n    }\\n    dlclose(libunwind);\\n  } else {\\n    DEBUG(print(\\\"libunwind.so could not be loaded\\\\n\\\"));\\n  }\\n  return -1;\\n}\\n#endif\\n\\n/* Call the old handler. */\\nstatic void coffeecatch_call_old_signal_handler(const int code, siginfo_t *const si,\\n                                                       void * const sc) {\\n  /* Call the \\\"real\\\" Java handler for JIT and internals. */\\n  if (code >= 0 && code < SIG_NUMBER_MAX) {\\n    if (native_code_g.sa_old[code].sa_sigaction != NULL) {\\n      native_code_g.sa_old[code].sa_sigaction(code, si, sc);\\n    } else if (native_code_g.sa_old[code].sa_handler != NULL) {\\n      native_code_g.sa_old[code].sa_handler(code);\\n    }\\n  }\\n}\\n\\n/* Unflag \\\"on stack\\\" */\\nstatic void coffeecatch_revert_alternate_stack(void) {\\n#ifndef NO_USE_SIGALTSTACK\\n  stack_t ss;\\n  if (sigaltstack(NULL, &ss) == 0) {\\n    ss.ss_flags &= ~SS_ONSTACK;\\n    sigaltstack (&ss, NULL);\\n  }\\n#endif\\n}\\n\\n/* Try to jump to userland. */\\nstatic void coffeecatch_try_jump_userland(native_code_handler_struct*\\n                                                 const t,\\n                                                 const int code,\\n                                                 siginfo_t *const si,\\n                                                 void * const sc) {\\n  (void) si; /* UNUSED */\\n  (void) sc; /* UNUSED */\\n\\n  /* Valid context ? */\\n  if (t != NULL && t->ctx_is_set) {\\n    DEBUG(print(\\\"calling siglongjmp()\\\\n\\\"));\\n\\n    /* Invalidate the context */\\n    t->ctx_is_set = 0;\\n\\n    /* We need to revert the alternate stack before jumping. */\\n    coffeecatch_revert_alternate_stack();\\n\\n    /*\\n     * Note on async-signal-safety of siglongjmp() [POSIX] :\\n     * \\\"Note that longjmp() and siglongjmp() are not in the list of\\n     * async-signal-safe functions. This is because the code executing after\\n     * longjmp() and siglongjmp() can call any unsafe functions with the same\\n     * danger as calling those unsafe functions directly from the signal\\n     * handler. Applications that use longjmp() and siglongjmp() from within\\n     * signal handlers require rigorous protection in order to be portable.\\n     * Many of the other functions that are excluded from the list are\\n     * traditionally implemented using either malloc() or free() functions or\\n     * the standard I/O library, both of which traditionally use data\\n     * structures in a non-async-signal-safe manner. Since any combination of\\n     * different functions using a common data structure can cause\\n     * async-signal-safety problems, this volume of POSIX.1-2008 does not\\n     * define the behavior when any unsafe function is called in a signal\\n     * handler that interrupts an unsafe function.\\\"\\n     */\\n    siglongjmp(t->ctx, code);\\n  }\\n}\\n\\nstatic void coffeecatch_start_alarm(void) {\\n  /* Ensure we do not deadlock. Default of ALRM is to die.\\n   * (signal() and alarm() are signal-safe) */\\n  (void) alarm(30);\\n}\\n\\nstatic void coffeecatch_mark_alarm(native_code_handler_struct *const t) {\\n  t->alarm = 1;\\n}\\n\\n/* Copy context infos (signal code, etc.) */\\nstatic void coffeecatch_copy_context(native_code_handler_struct *const t,\\n                                     const int code, siginfo_t *const si,\\n                                     void *const sc) {\\n  t->code = code;\\n  t->si = *si;\\n  if (sc != NULL) {\\n    ucontext_t *const uc = (ucontext_t*) sc;\\n    t->uc = *uc;\\n  } else {\\n    memset(&t->uc, 0, sizeof(t->uc));\\n  }\\n\\n#ifdef USE_UNWIND\\n  /* Frame buffer initial position. */\\n  t->frames_size = 0;\\n\\n  /* Skip us and the caller. */\\n  t->frames_skip = 2;\\n\\n  /* Use the corkscrew library to extract the backtrace. */\\n#ifdef USE_CORKSCREW\\n  t->frames_size = coffeecatch_backtrace_signal(si, sc, t->frames, 0,\\n                                                BACKTRACE_FRAMES_MAX);\\n#else\\n  /* Unwind frames (equivalent to backtrace()) */\\n  _Unwind_Backtrace(coffeecatch_unwind_callback, t);\\n#endif\\n\\n#ifdef USE_LIBUNWIND\\n  if (t->frames_size == 0) {\\n    size_t i;\\n    t->frames_size = coffeecatch_unwind_signal(si, sc, t->uframes, 0,\\n                                               BACKTRACE_FRAMES_MAX);\\n    for(i = 0 ; i < t->frames_size ; i++) {\\n      t->frames[i].absolute_pc = (uintptr_t) t->uframes[i];\\n      t->frames[i].stack_top = 0;\\n      t->frames[i].stack_size = 0;\\n    }\\n  }\\n#endif\\n\\n  if (t->frames_size != 0) {\\n    DEBUG(print(\\\"called _Unwind_Backtrace()\\\\n\\\"));\\n  } else {\\n    DEBUG(print(\\\"called _Unwind_Backtrace(), but no traces\\\\n\\\"));\\n  }\\n#endif\\n}\\n\\n/* Return the thread-specific native_code_handler_struct structure, or\\n * @c null if no such structure is available. */\\nstatic native_code_handler_struct* coffeecatch_get() {\\n  return (native_code_handler_struct*)\\n      pthread_getspecific(native_code_thread);\\n}\\n\\nint coffeecatch_cancel_pending_alarm() {\\n  native_code_handler_struct *const t = coffeecatch_get();\\n  if (t != NULL && t->alarm) {\\n    t->alarm = 0;\\n    /* \\\"If seconds is 0, a pending alarm request, if any, is canceled.\\\" */\\n    alarm(0);\\n    return 0;\\n  }\\n  return -1;\\n}\\n\\n/* Internal signal pass-through. Allows to peek the \\\"real\\\" crash before\\n * calling the Java handler. Remember than Java needs many of the signals\\n * (for the JIT, for test-free NullPointerException handling, etc.)\\n * We record the siginfo_t context in this function each time it is being\\n * called, to be able to know what error caused an issue.\\n */\\nstatic void coffeecatch_signal_pass(const int code, siginfo_t *const si,\\n                                    void *const sc) {\\n  native_code_handler_struct *t;\\n\\n  DEBUG(print(\\\"caught signal\\\\n\\\"));\\n\\n  /* Call the \\\"real\\\" Java handler for JIT and internals. */\\n  coffeecatch_call_old_signal_handler(code, si, sc);\\n\\n  /* Still here ?\\n   * FIXME TODO: This is the Dalvik behavior - but is it the SunJVM one ? */\\n\\n  /* Ensure we do not deadlock. Default of ALRM is to die.\\n   * (signal() and alarm() are signal-safe) */\\n  signal(code, SIG_DFL);\\n  coffeecatch_start_alarm();\\n\\n  /* Available context ? */\\n  t = coffeecatch_get();\\n  if (t != NULL) {\\n    /* An alarm() call was triggered. */\\n    coffeecatch_mark_alarm(t);\\n\\n    /* Take note of the signal. */\\n    coffeecatch_copy_context(t, code, si, sc);\\n\\n    /* Back to the future. */\\n    coffeecatch_try_jump_userland(t, code, si, sc);\\n  }\\n\\n  /* Nope. (abort() is signal-safe) */\\n  DEBUG(print(\\\"calling abort()\\\\n\\\"));\\n  signal(SIGABRT, SIG_DFL);\\n  abort();\\n}\\n\\n/* Internal crash handler for abort(). Java calls abort() if its signal handler\\n * could not resolve the signal ; thus calling us through this handler. */\\nstatic void coffeecatch_signal_abort(const int code, siginfo_t *const si,\\n                                            void *const sc) {\\n  native_code_handler_struct *t;\\n\\n  (void) sc; /* UNUSED */\\n\\n  DEBUG(print(\\\"caught abort\\\\n\\\"));\\n\\n  /* Ensure we do not deadlock. Default of ALRM is to die.\\n   * (signal() and alarm() are signal-safe) */\\n  signal(code, SIG_DFL);\\n  coffeecatch_start_alarm();\\n\\n  /* Available context ? */\\n  t = coffeecatch_get();\\n  if (t != NULL) {\\n    /* An alarm() call was triggered. */\\n    coffeecatch_mark_alarm(t);\\n\\n    /* Take note (real \\\"abort()\\\") */\\n    coffeecatch_copy_context(t, code, si, sc);\\n\\n    /* Back to the future. */\\n    coffeecatch_try_jump_userland(t, code, si, sc);\\n  }\\n\\n  /* No such restore point, call old signal handler then. */\\n  DEBUG(print(\\\"calling old signal handler\\\\n\\\"));\\n  coffeecatch_call_old_signal_handler(code, si, sc);\\n\\n  /* Nope. (abort() is signal-safe) */\\n  DEBUG(print(\\\"calling abort()\\\\n\\\"));\\n  abort();\\n}\\n\\n/* Internal globals initialization. */\\nstatic int coffeecatch_handler_setup_global(void) {\\n  if (native_code_g.initialized++ == 0) {\\n    size_t i;\\n    struct sigaction sa_abort;\\n    struct sigaction sa_pass;\\n\\n    DEBUG(print(\\\"installing global signal handlers\\\\n\\\"));\\n\\n    /* Setup handler structure. */\\n    memset(&sa_abort, 0, sizeof(sa_abort));\\n    sigemptyset(&sa_abort.sa_mask);\\n    sa_abort.sa_sigaction = coffeecatch_signal_abort;\\n    sa_abort.sa_flags = SA_SIGINFO | SA_ONSTACK;\\n\\n    memset(&sa_pass, 0, sizeof(sa_pass));\\n    sigemptyset(&sa_pass.sa_mask);\\n    sa_pass.sa_sigaction = coffeecatch_signal_pass;\\n    sa_pass.sa_flags = SA_SIGINFO | SA_ONSTACK;\\n\\n    /* Allocate */\\n    native_code_g.sa_old = calloc(sizeof(struct sigaction), SIG_NUMBER_MAX);\\n    if (native_code_g.sa_old == NULL) {\\n      return -1;\\n    }\\n\\n    /* Setup signal handlers for SIGABRT (Java calls abort()) and others. **/\\n    for (i = 0; native_sig_catch[i] != 0; i++) {\\n      const int sig = native_sig_catch[i];\\n      const struct sigaction * const action =\\n          sig == SIGABRT ? &sa_abort : &sa_pass;\\n      assert(sig < SIG_NUMBER_MAX);\\n      if (sigaction(sig, action, &native_code_g.sa_old[sig]) != 0) {\\n        return -1;\\n      }\\n    }\\n\\n    /* Initialize thread var. */\\n    if (pthread_key_create(&native_code_thread, NULL) != 0) {\\n      return -1;\\n    }\\n\\n    DEBUG(print(\\\"installed global signal handlers\\\\n\\\"));\\n  }\\n\\n  /* OK. */\\n  return 0;\\n}\\n\\n/**\\n * Free a native_code_handler_struct structure.\\n **/\\nstatic int coffeecatch_native_code_handler_struct_free(native_code_handler_struct *const t) {\\n  int code = 0;\\n\\n  if (t == NULL) {\\n    return -1;\\n  }\\n\\n#ifndef NO_USE_SIGALTSTACK\\n  /* Restore previous alternative stack. */\\n  if (t->stack_old.ss_sp != NULL && sigaltstack(&t->stack_old, NULL) != 0) {\\n#ifndef USE_SILENT_SIGALTSTACK\\n    code = -1;\\n#endif\\n  }\\n#endif\\n\\n  /* Free alternative stack */\\n  if (t->stack_buffer != NULL) {\\n    free(t->stack_buffer);\\n    t->stack_buffer = NULL;\\n    t->stack_buffer_size = 0;\\n  }\\n\\n  /* Free structure. */\\n  free(t);\\n\\n  return code;\\n}\\n\\n/**\\n * Create a native_code_handler_struct structure.\\n **/\\nstatic native_code_handler_struct* coffeecatch_native_code_handler_struct_init(void) {\\n  stack_t stack;\\n  native_code_handler_struct *const t =\\n    calloc(sizeof(native_code_handler_struct), 1);\\n\\n  if (t == NULL) {\\n    return NULL;\\n  }\\n\\n  DEBUG(print(\\\"installing thread alternative stack\\\\n\\\"));\\n\\n  /* Initialize structure */\\n  t->stack_buffer_size = SIG_STACK_BUFFER_SIZE;\\n  t->stack_buffer = malloc(t->stack_buffer_size);\\n  if (t->stack_buffer == NULL) {\\n    coffeecatch_native_code_handler_struct_free(t);\\n    return NULL;\\n  }\\n\\n  /* Setup alternative stack. */\\n  memset(&stack, 0, sizeof(stack));\\n  stack.ss_sp = t->stack_buffer;\\n  stack.ss_size = t->stack_buffer_size;\\n  stack.ss_flags = 0;\\n\\n#ifndef NO_USE_SIGALTSTACK\\n  /* Install alternative stack. This is thread-safe */\\n  if (sigaltstack(&stack, &t->stack_old) != 0) {\\n#ifndef USE_SILENT_SIGALTSTACK\\n    coffeecatch_native_code_handler_struct_free(t);\\n    return NULL;\\n#endif\\n  }\\n#endif\\n\\n  return t;\\n}\\n\\n/**\\n * Acquire the crash handler for the current thread.\\n * The coffeecatch_handler_cleanup() must be called to release allocated\\n * resources.\\n **/\\nstatic int coffeecatch_handler_setup(int setup_thread) {\\n  int code;\\n\\n  DEBUG(print(\\\"setup for a new handler\\\\n\\\"));\\n\\n  /* Initialize globals. */\\n  if (pthread_mutex_lock(&native_code_g.mutex) != 0) {\\n    return -1;\\n  }\\n  code = coffeecatch_handler_setup_global();\\n  if (pthread_mutex_unlock(&native_code_g.mutex) != 0) {\\n    return -1;\\n  }\\n\\n  /* Global initialization failed. */\\n  if (code != 0) {\\n    return -1;\\n  }\\n\\n  /* Initialize locals. */\\n  if (setup_thread && coffeecatch_get() == NULL) {\\n    native_code_handler_struct *const t =\\n      coffeecatch_native_code_handler_struct_init();\\n\\n    if (t == NULL) {\\n      return -1;\\n    }\\n\\n    DEBUG(print(\\\"installing thread alternative stack\\\\n\\\"));\\n\\n    /* Set thread-specific value. */\\n    if (pthread_setspecific(native_code_thread, t) != 0) {\\n      coffeecatch_native_code_handler_struct_free(t);\\n      return -1;\\n    }\\n\\n    DEBUG(print(\\\"installed thread alternative stack\\\\n\\\"));\\n  }\\n\\n  /* OK. */\\n  return 0;\\n}\\n\\n/**\\n * Release the resources allocated by a previous call to\\n * coffeecatch_handler_setup().\\n * This function must be called as many times as\\n * coffeecatch_handler_setup() was called to fully release allocated\\n * resources.\\n **/\\nstatic int coffeecatch_handler_cleanup() {\\n  /* Cleanup locals. */\\n  native_code_handler_struct *const t = coffeecatch_get();\\n  if (t != NULL) {\\n    DEBUG(print(\\\"removing thread alternative stack\\\\n\\\"));\\n\\n    /* Erase thread-specific value now (detach). */\\n    if (pthread_setspecific(native_code_thread, NULL) != 0) {\\n      assert(! \\\"pthread_setspecific() failed\\\");\\n    }\\n\\n    /* Free handler and reset slternate stack */\\n    if (coffeecatch_native_code_handler_struct_free(t) != 0) {\\n      return -1;\\n    }\\n\\n    DEBUG(print(\\\"removed thread alternative stack\\\\n\\\"));\\n  }\\n\\n  /* Cleanup globals. */\\n  if (pthread_mutex_lock(&native_code_g.mutex) != 0) {\\n    assert(! \\\"pthread_mutex_lock() failed\\\");\\n  }\\n  assert(native_code_g.initialized != 0);\\n  if (--native_code_g.initialized == 0) {\\n    size_t i;\\n\\n    DEBUG(print(\\\"removing global signal handlers\\\\n\\\"));\\n\\n    /* Restore signal handler. */\\n    for(i = 0; native_sig_catch[i] != 0; i++) {\\n      const int sig = native_sig_catch[i];\\n      assert(sig < SIG_NUMBER_MAX);\\n      if (sigaction(sig, &native_code_g.sa_old[sig], NULL) != 0) {\\n        return -1;\\n      }\\n    }\\n\\n    /* Free old structure. */\\n    free(native_code_g.sa_old);\\n    native_code_g.sa_old = NULL;\\n\\n    /* Delete thread var. */\\n    if (pthread_key_delete(native_code_thread) != 0) {\\n      assert(! \\\"pthread_key_delete() failed\\\");\\n    }\\n\\n    DEBUG(print(\\\"removed global signal handlers\\\\n\\\"));\\n  }\\n  if (pthread_mutex_unlock(&native_code_g.mutex) != 0) {\\n    assert(! \\\"pthread_mutex_unlock() failed\\\");\\n  }\\n\\n  return 0;\\n}\\n\\n/**\\n * Get the signal associated with the crash.\\n */\\nint coffeecatch_get_signal() {\\n  const native_code_handler_struct* const t = coffeecatch_get();\\n  if (t != NULL) {\\n    return t->code;\\n  } else {\\n    return -1;\\n  }\\n}\\n\\n/* Signal descriptions.\\n   See <http://pubs.opengroup.org/onlinepubs/009696699/basedefs/signal.h.html>\\n*/\\nstatic const char* coffeecatch_desc_sig(int sig, int code) {\\n  switch(sig) {\\n  case SIGILL:\\n    switch(code) {\\n    case ILL_ILLOPC:\\n      return \\\"Illegal opcode\\\";\\n    case ILL_ILLOPN:\\n      return \\\"Illegal operand\\\";\\n    case ILL_ILLADR:\\n      return \\\"Illegal addressing mode\\\";\\n    case ILL_ILLTRP:\\n      return \\\"Illegal trap\\\";\\n    case ILL_PRVOPC:\\n      return \\\"Privileged opcode\\\";\\n    case ILL_PRVREG:\\n      return \\\"Privileged register\\\";\\n    case ILL_COPROC:\\n      return \\\"Coprocessor error\\\";\\n    case ILL_BADSTK:\\n      return \\\"Internal stack error\\\";\\n    default:\\n      return \\\"Illegal operation\\\";\\n    }\\n    break;\\n  case SIGFPE:\\n    switch(code) {\\n    case FPE_INTDIV:\\n      return \\\"Integer divide by zero\\\";\\n    case FPE_INTOVF:\\n      return \\\"Integer overflow\\\";\\n    case FPE_FLTDIV:\\n      return \\\"Floating-point divide by zero\\\";\\n    case FPE_FLTOVF:\\n      return \\\"Floating-point overflow\\\";\\n    case FPE_FLTUND:\\n      return \\\"Floating-point underflow\\\";\\n    case FPE_FLTRES:\\n      return \\\"Floating-point inexact result\\\";\\n    case FPE_FLTINV:\\n      return \\\"Invalid floating-point operation\\\";\\n    case FPE_FLTSUB:\\n      return \\\"Subscript out of range\\\";\\n    default:\\n      return \\\"Floating-point\\\";\\n    }\\n    break;\\n  case SIGSEGV:\\n    switch(code) {\\n    case SEGV_MAPERR:\\n      return \\\"Address not mapped to object\\\";\\n    case SEGV_ACCERR:\\n      return \\\"Invalid permissions for mapped object\\\";\\n    default:\\n      return \\\"Segmentation violation\\\";\\n    }\\n    break;\\n  case SIGBUS:\\n    switch(code) {\\n    case BUS_ADRALN:\\n      return \\\"Invalid address alignment\\\";\\n    case BUS_ADRERR:\\n      return \\\"Nonexistent physical address\\\";\\n    case BUS_OBJERR:\\n      return \\\"Object-specific hardware error\\\";\\n    default:\\n      return \\\"Bus error\\\";\\n    }\\n    break;\\n  case SIGTRAP:\\n    switch(code) {\\n    case TRAP_BRKPT:\\n      return \\\"Process breakpoint\\\";\\n    case TRAP_TRACE:\\n      return \\\"Process trace trap\\\";\\n    default:\\n      return \\\"Trap\\\";\\n    }\\n    break;\\n  case SIGCHLD:\\n    switch(code) {\\n    case CLD_EXITED:\\n      return \\\"Child has exited\\\";\\n    case CLD_KILLED:\\n      return \\\"Child has terminated abnormally and did not create a core file\\\";\\n    case CLD_DUMPED:\\n      return \\\"Child has terminated abnormally and created a core file\\\";\\n    case CLD_TRAPPED:\\n      return \\\"Traced child has trapped\\\";\\n    case CLD_STOPPED:\\n      return \\\"Child has stopped\\\";\\n    case CLD_CONTINUED:\\n      return \\\"Stopped child has continued\\\";\\n    default:\\n      return \\\"Child\\\";\\n    }\\n    break;\\n  case SIGPOLL:\\n    switch(code) {\\n    case POLL_IN:\\n      return \\\"Data input available\\\";\\n    case POLL_OUT:\\n      return \\\"Output buffers available\\\";\\n    case POLL_MSG:\\n      return \\\"Input message available\\\";\\n    case POLL_ERR:\\n      return \\\"I/O error\\\";\\n    case POLL_PRI:\\n      return \\\"High priority input available\\\";\\n    case POLL_HUP:\\n      return \\\"Device disconnected\\\";\\n    default:\\n      return \\\"Pool\\\";\\n    }\\n    break;\\n  case SIGABRT:\\n    return \\\"Process abort signal\\\";\\n  case SIGALRM:\\n    return \\\"Alarm clock\\\";\\n  case SIGCONT:\\n    return \\\"Continue executing, if stopped\\\";\\n  case SIGHUP:\\n    return \\\"Hangup\\\";\\n  case SIGINT:\\n    return \\\"Terminal interrupt signal\\\";\\n  case SIGKILL:\\n    return \\\"Kill\\\";\\n  case SIGPIPE:\\n    return \\\"Write on a pipe with no one to read it\\\";\\n  case SIGQUIT:\\n    return \\\"Terminal quit signal\\\";\\n  case SIGSTOP:\\n    return \\\"Stop executing\\\";\\n  case SIGTERM:\\n    return \\\"Termination signal\\\";\\n  case SIGTSTP:\\n    return \\\"Terminal stop signal\\\";\\n  case SIGTTIN:\\n    return \\\"Background process attempting read\\\";\\n  case SIGTTOU:\\n    return \\\"Background process attempting write\\\";\\n  case SIGUSR1:\\n    return \\\"User-defined signal 1\\\";\\n  case SIGUSR2:\\n    return \\\"User-defined signal 2\\\";\\n  case SIGPROF:\\n    return \\\"Profiling timer expired\\\";\\n  case SIGSYS:\\n    return \\\"Bad system call\\\";\\n  case SIGVTALRM:\\n    return \\\"Virtual timer expired\\\";\\n  case SIGURG:\\n    return \\\"High bandwidth data is available at a socket\\\";\\n  case SIGXCPU:\\n    return \\\"CPU time limit exceeded\\\";\\n  case SIGXFSZ:\\n    return \\\"File size limit exceeded\\\";\\n  default:\\n    switch(code) {\\n    case SI_USER:\\n      return \\\"Signal sent by kill()\\\";\\n    case SI_QUEUE:\\n      return \\\"Signal sent by the sigqueue()\\\";\\n    case SI_TIMER:\\n      return \\\"Signal generated by expiration of a timer set by timer_settime()\\\";\\n    case SI_ASYNCIO:\\n      return \\\"Signal generated by completion of an asynchronous I/O request\\\";\\n    case SI_MESGQ:\\n      return\\n        \\\"Signal generated by arrival of a message on an empty message queue\\\";\\n    default:\\n      return \\\"Unknown signal\\\";\\n    }\\n    break;\\n  }\\n}\\n\\n/**\\n * Get the backtrace size. Returns 0 if no backtrace is available.\\n */\\nsize_t coffeecatch_get_backtrace_size(void) {\\n#ifdef USE_UNWIND\\n  const native_code_handler_struct* const t = coffeecatch_get();\\n  if (t != NULL) {\\n    return t->frames_size;\\n  } else {\\n    return 0;\\n  }\\n#else\\n  return 0;\\n#endif\\n}\\n\\n/**\\n * Get the <index>th element of the backtrace, or 0 upon error.\\n */\\nuintptr_t coffeecatch_get_backtrace(ssize_t index) {\\n#ifdef USE_UNWIND\\n  const native_code_handler_struct* const t = coffeecatch_get();\\n  if (t != NULL) {\\n    if (index < 0) {\\n      index = t->frames_size + index;\\n    }\\n    if (index >= 0 && (size_t) index < t->frames_size) {\\n#ifdef USE_CORKSCREW\\n      return t->frames[index].absolute_pc;\\n#else\\n      return t->frames[index];\\n#endif\\n    }\\n  }\\n#else\\n  (void) index;\\n#endif\\n  return 0;\\n}\\n\\n/**\\n * Get the program counter, given a pointer to a ucontext_t context.\\n **/\\nstatic uintptr_t coffeecatch_get_pc_from_ucontext(const ucontext_t *uc) {\\n#if (defined(__arm__))\\n  return uc->uc_mcontext.arm_pc;\\n#elif defined(__aarch64__)\\n  return uc->uc_mcontext.pc;\\n#elif (defined(__x86_64__))\\n  return uc->uc_mcontext.gregs[REG_RIP];\\n#elif (defined(__i386))\\n  return uc->uc_mcontext.gregs[REG_EIP];\\n#elif (defined (__ppc__)) || (defined (__powerpc__))\\n  return uc->uc_mcontext.regs->nip;\\n#elif (defined(__hppa__))\\n  return uc->uc_mcontext.sc_iaoq[0] & ~0x3UL;\\n#elif (defined(__sparc__) && defined (__arch64__))\\n  return uc->uc_mcontext.mc_gregs[MC_PC];\\n#elif (defined(__sparc__) && !defined (__arch64__))\\n  return uc->uc_mcontext.gregs[REG_PC];\\n#elif (defined(__mips__))\\n  return uc->uc_mcontext.gregs[31];\\n#else\\n#error \\\"Architecture is unknown, please report me!\\\"\\n#endif\\n}\\n\\n/* Is this module name look like a DLL ?\\n   FIXME: find a better way to do that...  */\\nstatic int coffeecatch_is_dll(const char *name) {\\n  size_t i;\\n  for(i = 0; name[i] != '\\\\0'; i++) {\\n    if (name[i + 0] == '.' &&\\n        name[i + 1] == 's' &&\\n        name[i + 2] == 'o' &&\\n        ( name[i + 3] == '\\\\0' || name[i + 3] == '.') ) {\\n      return 1;\\n    }\\n  }\\n  return 0;\\n}\\n\\n/* Extract a line information on a PC address. */\\nstatic void format_pc_address_cb(uintptr_t pc, \\n                                 void (*fun)(void *arg, const char *module, \\n                                             uintptr_t addr,\\n                                             const char *function,\\n                                             uintptr_t offset), void *arg) {\\n  if (pc != 0) {\\n    Dl_info info;\\n    void * const addr = (void*) pc;\\n    /* dladdr() returns 0 on error, and nonzero on success. */\\n    if (dladdr(addr, &info) != 0 && info.dli_fname != NULL) {\\n      const uintptr_t near = (uintptr_t) info.dli_saddr;\\n      const uintptr_t offs = pc - near;\\n      const uintptr_t addr_rel = pc - (uintptr_t) info.dli_fbase;\\n      /* We need the absolute address for the main module (?).\\n         TODO FIXME to be investigated. */\\n      const uintptr_t addr_to_use = coffeecatch_is_dll(info.dli_fname)\\n        ? addr_rel : pc;\\n      fun(arg, info.dli_fname, addr_to_use, info.dli_sname, offs);\\n    } else {\\n      fun(arg, NULL, pc, NULL, 0);\\n    }\\n  }\\n}\\n\\ntypedef struct t_print_fun {\\n  char *buffer;\\n  size_t buffer_size;\\n} t_print_fun;\\n\\nstatic void print_fun(void *arg, const char *module, uintptr_t uaddr,\\n                      const char *function, uintptr_t offset) {\\n  t_print_fun *const t = (t_print_fun*) arg;\\n  char *const buffer = t->buffer;\\n  const size_t buffer_size = t->buffer_size;\\n  const void*const addr = (void*) uaddr;\\n  if (module == NULL) {\\n    snprintf(buffer, buffer_size, \\\"[at %p]\\\", addr);\\n  } else if (function != NULL) {\\n    snprintf(buffer, buffer_size, \\\"[at %s:%p (%s+0x%x)]\\\", module, addr,\\n             function, (int) offset);\\n  } else {\\n    snprintf(buffer, buffer_size, \\\"[at %s:%p]\\\", module, addr);\\n  }\\n}\\n\\n/* Format a line information on a PC address. */\\nstatic void format_pc_address(char *buffer, size_t buffer_size, uintptr_t pc) {\\n  t_print_fun t;\\n  t.buffer = buffer;\\n  t.buffer_size = buffer_size;\\n  format_pc_address_cb(pc, print_fun, &t);\\n}\\n\\n/**\\n * Get the full error message associated with the crash.\\n */\\nconst char* coffeecatch_get_message() {\\n  const int error = errno;\\n  const native_code_handler_struct* const t = coffeecatch_get();\\n\\n  /* Found valid handler. */\\n  if (t != NULL) {\\n    char * const buffer = t->stack_buffer;\\n    const size_t buffer_len = t->stack_buffer_size;\\n    size_t buffer_offs = 0;\\n\\n    const char* const posix_desc =\\n      coffeecatch_desc_sig(t->si.si_signo, t->si.si_code);\\n\\n    /* Assertion failure ? */\\n    if ((t->code == SIGABRT\\n#ifdef __ANDROID__\\n        /* See Android BUG #16672:\\n         * \\\"C assert() failure causes SIGSEGV when it should cause SIGABRT\\\" */\\n        || (t->code == SIGSEGV && (uintptr_t) t->si.si_addr == 0xdeadbaad)\\n#endif\\n        ) && t->expression != NULL) {\\n      snprintf(&buffer[buffer_offs], buffer_len - buffer_offs,\\n          \\\"assertion '%s' failed at %s:%d\\\",\\n          t->expression, t->file, t->line);\\n      buffer_offs += strlen(&buffer[buffer_offs]);\\n    }\\n    /* Signal */\\n    else {\\n      snprintf(&buffer[buffer_offs], buffer_len - buffer_offs, \\\"signal %d\\\",\\n               t->si.si_signo);\\n      buffer_offs += strlen(&buffer[buffer_offs]);\\n\\n      /* Description */\\n      snprintf(&buffer[buffer_offs], buffer_len - buffer_offs, \\\" (%s)\\\",\\n               posix_desc);\\n      buffer_offs += strlen(&buffer[buffer_offs]);\\n\\n      /* Address of faulting instruction */\\n      if (t->si.si_signo == SIGILL || t->si.si_signo == SIGSEGV) {\\n        snprintf(&buffer[buffer_offs], buffer_len - buffer_offs, \\\" at address %p\\\",\\n                 t->si.si_addr);\\n        buffer_offs += strlen(&buffer[buffer_offs]);\\n      }\\n    }\\n\\n    /* [POSIX] If non-zero, an errno value associated with this signal,\\n     as defined in <errno.h>. */\\n    if (t->si.si_errno != 0) {\\n      snprintf(&buffer[buffer_offs], buffer_len - buffer_offs, \\\": \\\");\\n      buffer_offs += strlen(&buffer[buffer_offs]);\\n      if (strerror_r(t->si.si_errno, &buffer[buffer_offs],\\n                     buffer_len - buffer_offs) == 0) {\\n        snprintf(&buffer[buffer_offs], buffer_len - buffer_offs,\\n                 \\\"unknown error\\\");\\n        buffer_offs += strlen(&buffer[buffer_offs]);\\n      }\\n    }\\n\\n    /* Sending process ID. */\\n    if (t->si.si_signo == SIGCHLD && t->si.si_pid != 0) {\\n      snprintf(&buffer[buffer_offs], buffer_len - buffer_offs,\\n               \\\" (sent by pid %d)\\\", (int) t->si.si_pid);\\n      buffer_offs += strlen(&buffer[buffer_offs]);\\n    }\\n\\n    /* Faulting program counter location. */\\n    if (coffeecatch_get_pc_from_ucontext(&t->uc) != 0) {\\n      const uintptr_t pc = coffeecatch_get_pc_from_ucontext(&t->uc);\\n      snprintf(&buffer[buffer_offs], buffer_len - buffer_offs, \\\" \\\");\\n      buffer_offs += strlen(&buffer[buffer_offs]);\\n      format_pc_address(&buffer[buffer_offs], buffer_len - buffer_offs, pc);\\n      buffer_offs += strlen(&buffer[buffer_offs]);\\n    }\\n\\n    /* Return string. */\\n    buffer[buffer_offs] = '\\\\0';\\n    return t->stack_buffer;\\n  } else {\\n    /* Static buffer in case of emergency */\\n    static char buffer[256];\\n#ifdef _GNU_SOURCE\\n    return strerror_r(error, &buffer[0], sizeof(buffer));\\n#else\\n    const int code = strerror_r(error, &buffer[0], sizeof(buffer));\\n    errno = error;\\n    if (code == 0) {\\n      return buffer;\\n    } else {\\n      return \\\"unknown error during crash handler setup\\\";\\n    }\\n#endif\\n  }\\n}\\n\\n#if (defined(USE_CORKSCREW))\\ntypedef struct t_coffeecatch_backtrace_symbols_fun {\\n  void (*fun)(void *arg, const char *module, uintptr_t addr,\\n              const char *function, uintptr_t offset);\\n  void *arg;\\n} t_coffeecatch_backtrace_symbols_fun;\\n\\nstatic void coffeecatch_backtrace_symbols_fun(void *arg, const backtrace_symbol_t *sym) {\\n  t_coffeecatch_backtrace_symbols_fun *const bt =\\n    (t_coffeecatch_backtrace_symbols_fun*) arg;\\n  const char *symbol = sym->demangled_name != NULL \\n    ? sym->demangled_name : sym->symbol_name;\\n  const uintptr_t rel = sym->relative_pc - sym->relative_symbol_addr;\\n  bt->fun(bt->arg, sym->map_name, sym->relative_pc, symbol, rel);\\n}\\n#endif\\n\\n/**\\n * Enumerate backtrace information.\\n */\\nvoid coffeecatch_get_backtrace_info(void (*fun)(void *arg,\\n                                    const char *module,\\n                                    uintptr_t addr,\\n                                    const char *function,\\n                                    uintptr_t offset), void *arg) {\\n  const native_code_handler_struct* const t = coffeecatch_get();\\n  if (t != NULL) {\\n    size_t i;\\n#if (defined(USE_CORKSCREW))\\n    t_coffeecatch_backtrace_symbols_fun bt;\\n    bt.fun = fun;\\n    bt.arg = arg;\\n    if (coffeecatch_backtrace_symbols(t->frames, t->frames_size,\\n                                      coffeecatch_backtrace_symbols_fun,\\n                                      &bt)) {\\n      return;\\n    }\\n#endif\\n    for(i = 0; i < t->frames_size; i++) {\\n      const uintptr_t pc = t->frames[i].absolute_pc;\\n      format_pc_address_cb(pc, fun, arg);\\n    }\\n  }\\n}\\n\\n/**\\n * Returns 1 if we are already inside a coffeecatch block, 0 otherwise.\\n */\\nint coffeecatch_inside() {\\n  native_code_handler_struct *const t = coffeecatch_get();\\n  if (t != NULL && t->reenter > 0) {\\n    t->reenter++;\\n    return 1;\\n  }\\n  return 0;\\n}\\n\\n/**\\n * Calls coffeecatch_handler_setup(1) to setup a crash handler, mark the\\n * context as valid, and return 0 upon success.\\n */\\nint coffeecatch_setup() {\\n  if (coffeecatch_handler_setup(1) == 0) {\\n    native_code_handler_struct *const t = coffeecatch_get();\\n    assert(t != NULL);\\n    assert(t->reenter == 0);\\n    t->reenter = 1;\\n    t->ctx_is_set = 1;\\n    return 0;\\n  } else {\\n    return -1;\\n  }\\n}\\n\\n/**\\n * Calls coffeecatch_handler_cleanup()\\n */\\nvoid coffeecatch_cleanup() {\\n  native_code_handler_struct *const t = coffeecatch_get();\\n  assert(t != NULL);\\n  assert(t->reenter > 0);\\n  t->reenter--;\\n  if (t->reenter == 0) {\\n    t->ctx_is_set = 0;\\n    coffeecatch_handler_cleanup();\\n  }\\n}\\n\\nsigjmp_buf* coffeecatch_get_ctx() {\\n  native_code_handler_struct* t = coffeecatch_get();\\n  assert(t != NULL);\\n  return &t->ctx;\\n}\\n\\nvoid coffeecatch_abort(const char* exp, const char* file, int line) {\\n  native_code_handler_struct *const t = coffeecatch_get();\\n  if (t != NULL) {\\n    t->expression = exp;\\n    t->file = file;\\n    t->line = line;\\n  }\\n  abort();\\n}\\n\")\n")
