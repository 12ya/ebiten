// Code generated by file2byteslice. DO NOT EDIT.
// (gofmt is fine after generating)

package main

var coffeejni_c_go = []byte("// Code generated by file2byteslice. DO NOT EDIT.\n// (gofmt is fine after generating)\n\n// +build ebitenmobilegobind\n\npackage main\n\nvar coffeejni_c = []byte(\"/* CoffeeCatch, a tiny native signal handler/catcher for JNI code.\\n * (especially for Android/Dalvik)\\n *\\n * Copyright (c) 2013, Xavier Roche (http://www.httrack.com/)\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * 1. Redistributions of source code must retain the above copyright notice, this\\n *    list of conditions and the following disclaimer.\\n * 2. Redistributions in binary form must reproduce the above copyright notice,\\n *    this list of conditions and the following disclaimer in the documentation\\n *    and/or other materials provided with the distribution.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND\\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n#ifndef COFFEECATCH_JNI_H\\n#define COFFEECATCH_JNI_H\\n\\n#include <stdio.h>\\r\\n#include <string.h>\\r\\n#include <stdint.h>\\n#include <sys/types.h>\\n#include <jni.h>\\n#include <assert.h>\\r\\n#include \\\"coffeecatch.h\\\"\\n\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\ntypedef struct t_bt_fun {\\n  JNIEnv* env;\\n  jclass cls;\\n  jclass cls_ste;\\n  jmethodID cons_ste;\\n  jobjectArray elements;\\n  size_t size;\\n  size_t index;\\n} t_bt_fun;\\n\\nstatic char* bt_print(const char *function, uintptr_t offset) {\\n  if (function != NULL) {\\n    char buffer[256];\\n    snprintf(buffer, sizeof(buffer), \\\"%s:%p\\\", function, (void*) offset);\\n    return strdup(buffer);\\n  } else {\\n    return \\\"<unknown>\\\";\\n  }\\n}\\n\\nstatic char* bt_addr(uintptr_t addr) {\\n  char buffer[32];\\n  snprintf(buffer, sizeof(buffer), \\\"%p\\\", (void*) addr);\\n  return strdup(buffer);\\n}\\n\\n#define IS_VALID_CLASS_CHAR(C) ( \\\\\\n  ((C) >= 'a' && (C) <= 'z')     \\\\\\n  || ((C) >= 'A' && (C) <= 'Z')  \\\\\\n  || ((C) >= '0' && (C) <= '9')  \\\\\\n  || (C) == '_'                  \\\\\\n  )\\n\\nstatic char* bt_module(const char *module) {\\n  if (module != NULL) {\\n    size_t i;\\n    char *copy;\\n    if (*module == '/') {\\n      module++;\\n    }\\n    copy = strdup(module);\\n    /* Pseudo-java-class. */\\n    for(i = 0; copy[i] != '\\\\0'; i++) {\\n      if (copy[i] == '/') {\\n        copy[i] = '.';\\n      } else if (!IS_VALID_CLASS_CHAR(copy[i])) {\\n        copy[i] = '_';\\n      }\\n    }\\n    return copy;\\n  } else {\\n    return \\\"<unknown>\\\";\\n  }\\n}\\n\\nstatic void bt_fun(void *arg, const char *module, uintptr_t addr, \\n                   const char *function, uintptr_t offset) {\\n  t_bt_fun *const t = (t_bt_fun*) arg;\\n  JNIEnv*const env = t->env;\\n  jstring declaringClass = (*env)->NewStringUTF(env, bt_module(module));\\n  jstring methodName = (*env)->NewStringUTF(env, bt_addr(addr));\\n  jstring fileName = (*env)->NewStringUTF(env, bt_print(function, offset));\\n  const int lineNumber = function != NULL ? 0 : -2;  /* \\\"-2\\\" is \\\"inside JNI code\\\" */\\n  jobject trace = (*env)->NewObject(env, t->cls_ste, t->cons_ste, \\n                                    declaringClass, methodName, fileName,\\n                                    lineNumber);\\n  if (t->index < t->size) {\\n    (*t->env)->SetObjectArrayElement(t->env, t->elements, t->index++, trace);\\n  }\\n}\\n\\nvoid coffeecatch_throw_exception(JNIEnv* env) {\\n  jclass cls = (*env)->FindClass(env, \\\"java/lang/Error\\\");\\n  jclass cls_ste = (*env)->FindClass(env, \\\"java/lang/StackTraceElement\\\");\\n\\n  jmethodID cons = (*env)->GetMethodID(env, cls, \\\"<init>\\\", \\\"(Ljava/lang/String;)V\\\");\\n  jmethodID cons_cause = (*env)->GetMethodID(env, cls, \\\"<init>\\\", \\\"(Ljava/lang/String;Ljava/lang/Throwable;)V\\\");\\n  jmethodID cons_ste = (*env)->GetMethodID(env, cls_ste, \\\"<init>\\\",\\n    \\\"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V\\\");\\n  jmethodID meth_sste = (*env)->GetMethodID(env, cls, \\\"setStackTrace\\\",\\n    \\\"([Ljava/lang/StackTraceElement;)V\\\");\\n\\n  /* Exception message. */\\n  const char*const message = coffeecatch_get_message();\\n  jstring str = (*env)->NewStringUTF(env, strdup(message));\\n\\n  /* Final exception. */\\n  jthrowable exception;\\n\\n  /* Add pseudo-stack trace. */\\n  const ssize_t bt_size = coffeecatch_get_backtrace_size();\\n\\n  assert(cls != NULL);\\n  assert(cls_ste != NULL);\\n  assert(cons != NULL);\\n  assert(cons_cause != NULL);\\n  assert(cons_ste != NULL);\\n  assert(meth_sste != NULL);\\n\\n  assert(message != NULL);\\n  assert(str != NULL);\\n\\n  /* Can we produce a stack trace ? */\\n  if (bt_size > 0) {\\n    /* Create secondary exception. */\\n    jthrowable cause = (jthrowable) (*env)->NewObject(env, cls, cons, str);\\n\\n    /* Stack trace. */\\n    jobjectArray elements =\\n      (*env)->NewObjectArray(env, bt_size, cls_ste, NULL);\\n    if (elements != NULL) {\\n      t_bt_fun t;\\n      t.env = env;\\n      t.cls = cls;\\n      t.cls_ste = cls_ste;\\n      t.cons_ste = cons_ste;\\n      t.elements = elements;\\n      t.index = 0;\\n      t.size = bt_size;\\n      coffeecatch_get_backtrace_info(bt_fun, &t);\\n      (*env)->CallVoidMethod(env, cause, meth_sste, elements);\\n    }\\n\\n    /* Primary exception */\\n    exception = (jthrowable) (*env)->NewObject(env, cls, cons_cause, str, cause);\\n  } else {\\n    /* Simple exception */\\n    exception = (jthrowable) (*env)->NewObject(env, cls, cons, str);\\n  }\\n\\n  /* Throw exception. */\\n  if (exception != NULL) {\\n    (*env)->Throw(env, exception);\\n  } else {\\n    (*env)->ThrowNew(env, cls, strdup(message));\\n  }\\n}\\n\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n#endif\\n\")\n")
